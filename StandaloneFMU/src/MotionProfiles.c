/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  %FILE_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* This file implements the functions necessary for motion profiles
   functions
*/

%IF%%NUMBEROF_DLL_MotionProfiles%
#include <math.h>
#include <stdio.h>
#include <string.h>

#include "xxtypes.h"
#include "MotionProfiles.h"

static char g_lastError[512];

#ifndef M_PI
#define M_PI 3.1415926535897932384626433832795
#endif
#ifndef M_TWOPI
#define M_TWOPI 6.283185307179586476925286766559
#endif
#ifndef M_FOURPI
#define M_FOURPI 12.566370614359172953850573533118
#endif
#ifndef M_SIXPI
#define M_SIXPI 18.849555921538759430775860299677
#endif
#ifndef M_HALFPI
#define M_HALFPI 1.5707963267948966192313216916398
#endif
#ifndef M_QRTRPI
#define M_QRTRPI 0.78539816339744830961566084581988
#endif
#ifndef M_PISQR
#define M_PISQR 9.8696044010893586188344909998762
#endif
#ifndef M_SQRT2
#define M_SQRT2 1.4142135623730950488016887242097
#endif

/* some prototypes */
XXInteger MotionProfileFlat(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileRamp(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileSine(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileCubic(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfilePartialCubic(XXDouble u, XXDouble cv, XXDouble ca, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileTrapezoidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfilePartialTrapezoidal(XXDouble u, XXDouble cv, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileModifiedTrapezoidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileCycloidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileStandardModifiedSine(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileModifiedSineWithConstantVelocity(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileGeneralModifiedSineWithConstantVelocity(XXDouble u, XXDouble alpha, XXDouble n,
														   XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfilePolynomial345(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfilePolynomial13579(XXDouble u, XXDouble bb, XXDouble bm,
								  XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileCrankRod(XXDouble u, XXDouble crankLength, XXDouble rodLength,
						   XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);
XXInteger MotionProfileGenevaMechanism(XXDouble u,
								  XXDouble *fu, XXDouble *dfu, XXDouble *d2fu);



void MotionProfiles_Initialize (void)
{

}

void MotionProfiles_Terminate (void)
{

}

XXString LastErrorMessage(void)
{
	return g_lastError;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileFlat(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileFlat(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileRamp(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileRamp(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileSine(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileSine(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileCubic(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileCubic(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = [u, cv, ca]
 *		cv = [0..1], constant velocity period
 *		ca = [0..0.2], constant acceleration period
 *		cv + 2*ca < 1
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfilePartialCubic(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];
	XXDouble cv = inarr[1];
	XXDouble ca = inarr[2];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */
	/* do some checks */

	if( cv < 0.0 || cv > 1.0 )
	{
		sprintf(g_lastError, "The Continuous Velocity must be in range [0..100]%%");
		return 1;
	}
	if( ca < 0.0 || ca > 1.0)
	{
		sprintf(g_lastError, "The Continuous Acceleration must be in range [0..100]%%");
		return 1;
	}
	if( cv + 2.0*ca >= 1.0 )
	{
		sprintf(g_lastError, "CV + 2*CA must be smaller than 100%%");
		return 1;
	}

	/* and call our function */
	MotionProfilePartialCubic(u, cv, ca, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileTrapezoidal(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileTrapezoidal(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = [u, cv] => cv = [0..1]
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfilePartialTrapezoidal(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];
	XXDouble cv = inarr[1];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* do some checks */
	if( cv < 0.0 || cv >= 1.0 )
	{
		sprintf(g_lastError, "The Continuous Velocity must be in range [0..100]%%");
		return 1;
	}


	/* and call our function */
	MotionProfilePartialTrapezoidal(u, cv, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileModifiedTrapezoidal(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileModifiedTrapezoidal(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileCycloidal(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileCycloidal(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileStandardModifiedSine(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileStandardModifiedSine(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileModifiedSineWithConstantVelocity(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileModifiedSineWithConstantVelocity(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = [u, alpha, n]
 *         alpha [0 .. 0.5]
 *         n = [alpha .. 0.5]
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileGeneralModifiedSineWithConstantVelocity(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];
	XXDouble alpha = inarr[1];
	XXDouble n = inarr[2];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* do some checks */
	if( alpha < 0.0 || alpha > 0.5 )
	{
		strncpy(g_lastError, "Alpha must be in range [0..50]%%", 512);
		return 1;
	}
	if( n < alpha || n > 0.5 )
	{
		strncpy(g_lastError, "N must be in range [alpha..50]%%", 512);
		return 1;
	}


	/* and call our function */
	MotionProfileGeneralModifiedSineWithConstantVelocity(u, alpha, n, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfilePolynomial345(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfilePolynomial345(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}
/*
 * inarr = [u, bb, bm]
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfilePolynomial13579(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{

	/* map the input */
	XXDouble u = inarr[0];
	XXDouble bb = inarr[1];
	XXDouble bm = inarr[2];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	if( inputs != 3 )
		return 1;
	if( outputs != 3 )
		return 1;

	/* and call our function */
	MotionProfilePolynomial13579(u, bb, bm, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = [u, crankLength, rodLength] : u = normalized. stroke and rodLength are not
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileCrankRod(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];
	XXDouble crankLength = inarr[1];
	XXDouble rodLength = inarr[2];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* do some checks */
	if( crankLength <= 0.0 )
	{
		strncpy(g_lastError, "The Crank Length must be larger then zero", 512);
		return 1;
	}
	if( rodLength <= 0.0 )
	{
		strncpy(g_lastError, "The Rod Length must be larger then zero", 512);
		return 1;
	}
	if( rodLength <= crankLength )
	{
		strncpy(g_lastError, "The Crank Length must be smaller than the Rod Length", 512);
		return 1;
	}


	/* and call our function */
	MotionProfileCrankRod(u, crankLength, rodLength, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}

/*
 * inarr = u
 * output = [fu, dfu, d2fu]
 */
XXInteger MotionProfiles_ProfileGenevaMechanism(XXDouble *inarr, XXInteger inputs, XXDouble *outarr, XXInteger outputs, XXInteger major)
{
	/* map the input */
	XXDouble u = inarr[0];

	/* map the outputs */
	XXDouble *fu = &(outarr[0]);		/* usually x */
	XXDouble *dfu = &(outarr[1]);		/* usually v */
	XXDouble *d2fu = &(outarr[2]);	/* usually a */

	/* and call our function */
	MotionProfileGenevaMechanism(u, fu, dfu, d2fu);

	/* return 0 means no error. */
	return 0;
}


/* u is unused */
XXInteger MotionProfileFlat(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	if( fu )
		*fu = 0.0;
	if( dfu )
		*dfu = 0.0;
	if( d2fu )
		*d2fu = 0.0;

	return 1;
}

XXInteger MotionProfileRamp(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	if( dfu )
		*dfu = 0.0;
	if( d2fu )
		*d2fu = 0.0;

	if( fu == NULL )
		return 1;

	if( u < 0.0 )
	{
		*fu = 0.0;
		return 1;
	}

	if( u > 1.0 )
	{
		*fu = 1.0;
		return 1;
	}

	*fu = u;
	return 1;
}

XXInteger MotionProfileSine(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	if( fu )
		*fu = 0.5 - 0.5 * cos(M_PI * u);

	if( dfu )
		*dfu = M_HALFPI * sin(M_PI * u);

	if( d2fu )
		*d2fu = M_HALFPI * M_PI * cos(M_PI * u);

	return 1;
}

XXInteger MotionProfileCubic(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXInteger region;
	XXDouble uSqr;
	XXDouble uTrip;

	region = 0;

	if( u == 0.0 )
	{
		region = 1;
	}
	else
	{
		if( u <= 0.25 )
			region = 2;
		else
		{
			if( u <= 0.75 )
				region = 3;
			else
			{
				if( u <= 1.0 )
					region = 4;
			}
		}
	}

	uSqr = u * u;
	uTrip = uSqr * u;

	if( fu )
	{
		switch(region)
		{
			case 1: /* u == 0.0 */
				*fu = 0.0;
				break;

			case 2: /* u <= 0.25 */
				*fu = 16.0 * uTrip / 3.0;
				break;

			case 3: /* u <= 0.75 */
				*fu = 1.0/6.0 - 2.0 * u + 8.0 * uSqr - 16.0 * uTrip / 3.0;
				break;

			case 4: /* u <= 0.75 */
				*fu = -13.0/3.0 + 16.0 * u - 16.0 * uSqr + 16.0 * uTrip / 3.0;
				break;

			default:
				*fu = 1.0;
				break;
		}
	}

	if( dfu )
	{
		switch(region)
		{
			case 1: /* u == 0.0 */
				*dfu = 0.0;
				break;

			case 2: /* u <= 0.25 */
				*dfu = 16.0 *uSqr;
				break;

			case 3: /* u <= 0.75 */
				*dfu = -2.0 + 16.0 * u - 16.0 * uSqr;
				break;

			case 4: /* u <= 0.75 */
				*dfu = 16.0 - 32.0 * u + 16 * uSqr;
				break;

			default:
				*dfu = 0.0;
				break;
		}
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1: /* u == 0.0 */
				*d2fu = 0.0;
				break;

			case 2:/* u <= 0.25 */
				*d2fu = 32.0 * u;
				break;

			case 3: /* u <= 0.75 */
				*d2fu = 16.0 - 32.0 * u;
				break;

			case 4: /* u <= 0.75 */
				*d2fu = -32.0 + 32.0 * u;
				break;

			default:
				*d2fu = 0.0;
				break;
		}
	}
	return 1;
}

/*
 * cv = [0..1], constant velocity period
 * ca = [0..0.2], constant acceleration period
 * cv + 2*ca < 1
 */
XXInteger MotionProfilePartialCubic(XXDouble u, XXDouble cv, XXDouble ca, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble a_max, cy;

	XXDouble H, dH, d2H;

	XXDouble uSqr;
	XXDouble uTrip;

	XXDouble cySqr;
	XXDouble cyTrip;
	XXDouble dummy;
	XXDouble dummySqr;
	XXDouble dummyTrip;

	XXInteger region;

	a_max =  8.0 / (1.0 + 2.0 * ca + 2.0 * ca * cv - cv * cv);
	cy = 0.25 - 0.5 * ca - 0.25 * cv;

	region = 0;


	if( u == 0.0 )
	{
		region = 1;
	}
	else
	{
		if( u <= cy )
			region = 2;
		else
		{
			if( u <= cy + ca )
				region = 3;
			else
			{
				if( u <= 2.0 * cy + ca )
					region = 4;
				else
				{
					if( u <= 2.0 * cy + ca + cv )
						region = 5;
					else
					{
						if( u <= 3.0 * cy + ca + cv )
							region = 6;
						else
						{
							if( u <= 3.0 * cy + 2.0 * ca + cv )
								region = 7;
							else
							{
								if( u < 1 )
									region = 8;
							}
						}
					}
				}
			}
		}
	}

	uSqr = u * u;
	uTrip = uSqr * u;

	if( fu )
	{
		switch(region)
		{
			case 1:
				H = 0.0;
				break;

			case 2:
				H = uTrip / 6.0;
				break;

			case 3:
				cySqr = cy * cy;
				cyTrip = cySqr * cy;
				H = cyTrip / 6.0 - 0.5 * u *( cySqr - u * cy);
				break;

			case 4:
				dummy = cy + ca;
				dummySqr = dummy * dummy;
				dummyTrip = dummySqr * dummy;
				cySqr = cy * cy;
				cyTrip = cySqr * cy;
				H = (dummyTrip + cyTrip - uTrip)/ 6.0 +
					(-cy * ca - 0.5 * ca * ca - cySqr) * u +
					0.5 * (2.0 * cy + ca) * uSqr;
				break;

			case 5:
				dummy = 2*cy+ca;
				dummySqr = dummy * dummy;
				cySqr = cy * cy;
				H = 0.5 * dummy * (cySqr - dummy * cy) + (cy * ca + cySqr) * u;
				break;

			case 6:
				dummy = 2*cy+ca+cv;
				dummySqr = dummy * dummy;
				dummyTrip = dummySqr * dummy;
				cySqr = cy * cy;
				cyTrip = cySqr * cy;
				H =  dummyTrip / 6.0 - cyTrip- 1.5 * cySqr * ca - 0.5 * cy * ca * ca +
					 (cy*ca+ cySqr - 0.5 * dummySqr)*u + 0.5 * dummy * uSqr - uTrip / 6.0;
				break;

			case 7:
				dummy = 3.0 * cy + ca + cv;
				dummySqr = dummy * dummy;
				cySqr = cy * cy;
				cyTrip = cySqr * cy;
				H =  2.0 * dummy * cySqr -
					 dummySqr * cy + dummy * cy * cv -
					 7.0/6.0 * cyTrip - 0.5 * cy * cv * cv -
					 1.5 * cv * cySqr +
					 (cySqr/2 + (3.0 * cy+2.0*ca+cv)*cy)*u -
					 0.5 * cy * uSqr;
				break;

			case 8:
				dummy = cv + 2.0 * ca + 4.0 * cy;
				H = -0.5 * cv - ca - 15.0 * cy / 8.0 +
					1.0/3.0 + 0.25 * cy * ca * ( 1.0 + cv ) -
					0.125 * cy *cv * cv + ( dummy - 0.5) * u -
					0.5 * dummy * uSqr + uTrip / 6.0;
				break;

			default:
				H = cy * (1.0 + 2.0 * ca + 2.0 * ca * cv - cv * cv) / 8.0;
				break;
		}

		*fu = H * a_max / cy;
	}

	if( dfu )
	{
		switch(region)
		{
			case 1:
				dH = 0.0;
				break;

			case 2:
				dH = 0.5 * uSqr;
				break;

			case 3:
				dH = cy * (u - 0.5 * cy);
				break;

			case 4:
				cySqr = cy * cy;
				dH = -cy * ca - 0.5 * (ca * ca + uSqr) - cySqr + (2.0 * cy + ca) * u;
				break;

			case 5:
				dH = cy * (ca + cy);
				break;

			case 6:
				dummy = cv + ca + 2 *cy; /* also in calculation H */
				dH = cy * (ca + cy) + dummy * (u - 0.5 * dummy) - 0.5 * uSqr;
				break;

			case 7:
				cySqr = cy * cy;
				dummy = 3.0 * cy + 2.0 * ca + cv; /* also in H calculation */
				dH = 0.5 * cySqr + cy * ( dummy - u);
				break;

			case 8:
				dummy = cv + 2.0 * ca + 4.0 * cy;
				dH = dummy - dummy * u + 0.5 * uSqr - 0.5;
				break;

			default:
				dH = 0;
				break;
		}

		*dfu = dH * a_max / cy;
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1:
				d2H = 0.0;
				break;

			case 2:
				d2H = u;
				break;

			case 3:
				d2H = cy;
				break;

			case 4:
				d2H = 2.0 * cy + ca - u;
				break;

			case 5:
				d2H = 0.0;
				break;

			case 6:
				d2H = cv + ca +2.0 * cy -u;
				break;

			case 7:
				d2H = -cy;
				break;

			case 8:
				d2H = u - cv -2.0 *ca -4.0 * cy;
				break;

			default:
				d2H = 0.0;
				break;
		}

		*d2fu = d2H * a_max / cy;
	}

	return 1;
}

XXInteger MotionProfileTrapezoidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXInteger region;
	region = 0;

	if( u == 0.0 )
	{
		region = 1;
	}
	else
	{
		if( u <= 0.5 )
		{
			region = 2;
		}
		else
		{
			if( u < 1.0 )
			{
				region = 3;
			}
		}
	}

	if( fu )
	{
		switch(region)
		{
			case 1:
				*fu = 0.0;
				break;

			case 2: /* u <= 0.5 */
				*fu = 2.0 * u * u;
				break;

			case 3: /* u > 0.5 && u < 1.0 */
				*fu = 4.0 * u - 2.0 * u * u - 1.0;
				break;

			default:
				*fu = 1.0;
				break;
		}
	}

	if( dfu )
	{
		switch(region)
		{
			case 1:
				*dfu = 0.0;
				break;

			case 2: /* u <= 0.5 */
				*dfu = 4 * u;
				break;

			case 3: /* u > 0.5 && u < 1.0 */
				*dfu = 4 * (1.0 - u);
				break;

			default:
				*dfu = 0.0;
				break;
		}
	}
	if( d2fu )
	{
		switch(region)
		{
			case 1:
				*d2fu = 0.0;
				break;

			case 2: /* u <= 0.5 */
				*d2fu = 4.0;
				break;

			case 3: /* u > 0.5 && u < 1.0 */
				*d2fu = -4.0;
				break;

			default:
				*d2fu = 0.0;
				break;
		}
	}
	return 1;
}

XXInteger MotionProfileModifiedTrapezoidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble A;
	int region;

	A = (8.0 * M_PI / (2.0 + M_PI));

	region = 0;
	if( u < 0.125 )
		region = 1;
	else
	{
		if( u < 0.375 )
			region = 2;
		else
		{
			if( u < 0.625 )
				region = 3;
			else
			{
				if( u < 0.875 )
					region = 4;
				else
				{
					if( u < 1 )
						region = 5;
					else
						region = 0;
				}
			}
		}
	}

	if( fu )
	{
		switch(region)
		{
			case 1: /* u < 0.125 */
				*fu = A * ((u - sin(M_FOURPI * u) / M_FOURPI) / M_FOURPI);
				break;

			case 2: /* u < 0.375 */
				*fu = A * ((u * u) / 2.0 - 0.04542252 * u + 0.001479926023);
				break;

			case 3: /* u < 0.625 */
				*fu = A * (-0.006332573978 * cos(M_FOURPI * u - 4.71238898) + 0.329577471 * u - 0.0625);
				break;

			case 4: /* u < 0.875 */
				*fu = A * (-u * u / 2.0 + 0.954577471 * u - 0.25147992);
				break;

			case 5: /* u < 1 */
				*fu = A * (0.006332573978 * cos(M_FOURPI * u - 10.99557429) + 0.079577471 * u + 0.125);
				break;

			default: /* default */
				*fu = 1.0;
				break;
		}
	}

	if( dfu )
	{
		switch(region)
		{
			case 1: /* u < 0.125 */
				*dfu = A * ((1.0 - cos(M_FOURPI * u)) / (M_FOURPI));
				break;

			case 2: /* u < 0.375 */
				*dfu = A * (u + (0.25 / M_PI - 0.125));
				break;

			case 3: /* u < 0.625 */
				*dfu = A * ((sin(M_FOURPI * (u - 0.375))) / M_FOURPI + 0.25 + 0.25 / M_PI);
				break;

			case 4: /* u < 0.875 */
				*dfu = A * (-u + (7.0 + 2.0 / M_PI) / 8.0);
				break;

			case 5: /* u < 1 */
				*dfu = A * ((-sin(M_FOURPI * (u - 0.875)) + 1.0) / M_FOURPI);
				break;

			default: /* default */
				*dfu = 0.0;
				break;
		}
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1: /* u < 0.125 */
				*d2fu = A * sin(M_FOURPI * u);
				break;

			case 2: /* u < 0.375 */
				*d2fu = A;
				break;

			case 3: /* u < 0.625 */
				*d2fu = A * cos(M_FOURPI * (u - 0.375));
				break;

			case 4: /* u < 0.875 */
				*d2fu = -A;
				break;

			case 5: /* u < 1 */
				*d2fu = -A * cos(M_FOURPI * (u - 0.875));
				break;

			default: /* default */
				*d2fu = 0.0;
				break;
		}
	}
	return 1;
}
/*
 *cv = [0..1]
 */
XXInteger MotionProfilePartialTrapezoidal(XXDouble u, XXDouble cv,
									 XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXInteger region;
	XXDouble a_max;

	region = 0;

	if( u == 0.0 )
	{
		region = 1;
	}
	else
	{
		if( u <= 0.5 * ( 1.0 - cv ) )
			region = 2;
		else
		{
			if( u <= 0.5 * ( 1.0 + cv ) )
				region = 3;
			else
			{
				if( u < 1.0 )
					region = 4;
			}
		}
	}

	if( cv < 1.0 )
		a_max = 4.0 / (1.0 - cv * cv);
	else
		a_max = 0.0;

	if( fu )
	{
		switch(region)
		{
			case 1: /* u == 0 */
				*fu = 0.0;
				break;

			case 2: /* u <= 0.5 ( 1.0 - cv ) */
				*fu = 0.5 * a_max * u * u;
				break;

			case 3: /* u <= 0.5 ( 1.0 + cv ) */
				*fu =  a_max * ( 0.125 * (1.0 - 2.0 * cv + cv * cv) +
							  ( 0.5 - 0.5 * cv) * (u - 0.5 + 0.5 * cv) );

				break;

			case 4: /* u < 1.0 */
				*fu = a_max * ( u - 0.5 * u * u - 0.25 * cv * cv - 0.25);
				break;

			default:
				*fu = 1.0;
				break;
		}
	}

	if( dfu )
	{
		switch(region)
		{
			case 1: /* u == 0 */
				*dfu = 0.0;
				break;

			case 2: /* u <= 0.5 ( 1.0 - cv ) */
				*dfu = a_max * u;
				break;

			case 3: /* u <= 0.5 ( 1.0 + cv ) */
				*dfu = a_max * (0.5 - 0.5 * cv);
				break;

			case 4: /* u < 1.0 */
				*dfu = a_max * (1.0 - u);
				break;

			default:
				*dfu = 0.0;
				break;
		}
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1: /* u == 0 */
				*d2fu = 0.0;
				break;

			case 2: /* u <= 0.5 ( 1.0 - cv ) */
				*d2fu = a_max;
				break;

			case 3: /* u <= 0.5 ( 1.0 + cv ) */
				*d2fu = 0.0;
				break;

			case 4: /* u < 1.0 */
				*d2fu = -a_max;
				break;

			default:
				*d2fu = 0.0;
				break;
		}
	}
	return 1;
}
XXInteger MotionProfileCycloidal(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXInteger region;
	region = 0;
	if( u == 0.0 )
	{
		region = 1;
		if( u == 1.0 )
			region = 2;
	}

	if( fu )
	{
		switch( region )
		{
			case 1:
				*fu = 0.0;
				break;
			case 2:
				*fu = 1.0;
				break;
			default:
				*fu = ( u - (sin(M_TWOPI * u)) / M_TWOPI);
				break;
		}
	}
	if( dfu )
	{
		switch( region )
		{
			case 1:
				*dfu = 0.0;
				break;
			case 2:
				*dfu = 0.0;
				break;
			default:
				*dfu = (1.0 - cos(M_TWOPI * u));
				break;
		}
	}
	if( d2fu )
	{
		switch( region )
		{
			case 1:
				*d2fu = 0.0;
				break;
			case 2:
				*d2fu = 0.0;
				break;
			default:
				*d2fu = M_TWOPI * sin(M_TWOPI * u);
				break;
		}
	}

	return 1;
}

XXInteger MotionProfileStandardModifiedSine(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble A, twoPi2;
	XXInteger region;

	twoPi2 = 2.0 * M_PISQR;
	A = 4.0 * M_PISQR / (4.0 + M_PI);

	region = 0;

	if( u < 0.125 )
		region = 1;
	else
	{
		if( u < 0.875 )
			region = 2;
		else
		{
			if( u < 1 )
				region = 3;
		}
	}

	if( fu )
	{
		switch( region )
		{
			case 1:
				*fu = A * ( 1.0 / M_FOURPI ) * ( u - ( 1.0 / M_FOURPI ) * sin ( M_FOURPI * u ) );
				break;
			case 2:
				*fu = A * ( -9.0/(8.0 * twoPi2) * cos ( (M_FOURPI / 3.0) * (u - 0.125 )) + u / M_FOURPI + 1.0 / twoPi2 );
				break;
			case 3:
				*fu = A * ( 0.006332573978 * cos ( u * M_FOURPI - 10.99557429 ) + u / M_FOURPI + 0.101321183 );
				break;
			default:
				*fu = 1.0;
				break;
		}
	}

	if( dfu )
	{
		switch( region )
		{
			case 1:
				*dfu = A * ( (1.0 - cos(4.0 * M_PI * u))/(4.0 * M_PI) );
				break;
			case 2:
				*dfu = A * ( (3.0 * sin( 4.0 * M_PI *( u - 0.125) / 3.0 ) + 1.0) / (4.0 * M_PI) );
				break;
			case 3:
				*dfu = A * ( (1.0 - sin( 4.0 * M_PI * (u - 0.875) ))/(4.0 * M_PI) );
				break;
			default:
				*dfu = 0.0;
				break;
		}
	}

	if( d2fu )
	{
		switch( region )
		{
			case 1:
				*d2fu = A * sin( 4.0 * M_PI * u );
				break;
			case 2:
				*d2fu = A * cos( 4.0 * M_PI * (u - 0.125) / 3.0 );
				break;
			case 3:
				*d2fu = - A * cos( 4.0 * M_PI * (u - 0.875) );
				break;
			default:
				*d2fu = 0.0;
				break;
		}
	}

	return 1;
}

XXInteger MotionProfileModifiedSineWithConstantVelocity(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble A;
	int region;

	A = 18.0 * M_PI / (3.0 + M_PI);

	region = 0;
	if( u < 1.0/12.0 )
		region = 1;
	else
	{
		if( u < 0.25 )
			region = 2;
		else
		{
			if( u < 0.75 )
				region = 3;
			else
			{
				if( u < 11.0 / 12.0 )
					region = 4;
				else
				{
					region = 0;
				}
			}
		}
	}

	switch(region)
	{
		case 1: /* u < 1/12 */
			if( fu )
				*fu = (A / M_SIXPI) * (u - sin(M_SIXPI * u) / M_SIXPI );
			if( dfu )
				*dfu = (A / M_SIXPI) * (1.0 - cos(M_SIXPI * u));
			*d2fu = A * sin(M_SIXPI * u);
			break;
		case 2: /* u < 0.25 */
			if( fu )
				*fu = (0.5 * A) * (0.5 * u * u - (1.0 / (M_SIXPI * M_SIXPI)) * cos(M_SIXPI * u - M_HALFPI) ) +
				A * u / M_SIXPI -
				A * u / 24.0 +
				A / 576.0 -
				A / (M_PISQR * 72.0);

			if( dfu )
				*dfu = (0.5 * A) * ( u + (1.0 / M_SIXPI) * sin(M_SIXPI * u - M_HALFPI) ) + A / M_SIXPI - A / 24.0;
			if( d2fu )
				*d2fu = 0.5 * A * (1.0 + cos(M_SIXPI * u - M_HALFPI));
			break;
		case 3: /* u < 0.75 */
			if( fu )
				*fu = A * u / M_SIXPI + A * u / 12.0 - A / 72.0;
			if( dfu )
				*dfu = A / M_SIXPI + A / 12.0;
			if( d2fu )
				*d2fu = 0.0;
			break;
		case 4: /* u < 11 / 12 */
			if( fu )
				*fu = -(0.5 * A)*( (1.0 / (M_SIXPI * M_SIXPI)) * cos(M_SIXPI * u - M_PI* 4.5) + 0.5 * u * u) +
				 A * u / M_SIXPI +
				 A * u * 11.0 / 24.0 +
				 A / (M_PISQR * 72.0) -
				 A * 89.0 / 576.0;
			if( dfu )
				*dfu = (0.5 * A) * ( (1.0 / M_SIXPI) * sin(M_SIXPI * u - M_PI * 4.5) - u ) + A / M_SIXPI + A * 11.0 / 24.0;
			if( d2fu )
				*d2fu = -0.5 * A * (1.0 - cos(M_SIXPI*u - M_PI * 4.5));
			break;
		default:
			if( fu )
				*fu = (A / M_SIXPI) * (u - (1.0 / M_SIXPI) * sin(M_SIXPI * u) ) + A / 18.0;
			if( dfu )
				*dfu = (A / M_SIXPI) * (1.0 - cos(M_SIXPI * u));
			if( d2fu )
				*d2fu = A * sin(M_SIXPI * u);
			break;
	}

	return 1;
}

XXInteger MotionProfileGeneralModifiedSineWithConstantVelocity(XXDouble u, XXDouble alpha, XXDouble n,
														   XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble A, B;
	XXDouble new_n;
	XXInteger region;

	B = 2.0 * alpha / M_PI;
	new_n = n / alpha;
	A = M_PISQR / ( 2.0 * alpha * (  4.0 * alpha * new_n * (new_n - 2.0) + M_PI * new_n * (1.0 - 2.0 * alpha * (new_n - 1.0))));

	region = 0;
	if( u < alpha )
		region = 1;
	else
	{
		if( u < new_n * alpha )
			region = 2;
		else
		{
			if( u < (1.0 - new_n * alpha) )
				region = 3;
			else
			{
				if( u < (1.0 - alpha) )
					region = 4;
				else
				{
					region = 0;
				}
			}
		}
	}

	if( fu )
	{
		switch(region)
		{
			case 1: /* u < alpha */
				*fu = A * B * (u - B * sin(u / B));
				break;

			case 2: /* u < new_n*alpha */
				*fu = A * B * ( u - (new_n - 1.0) * (new_n - 1.0) * B * cos( (u - alpha) / (B * (new_n-1)) ) + (B * new_n * (new_n - 2)));
				break;

			case 3: /* u < (1-new_n*alpha) */
				*fu = A * B * new_n * ( u + alpha * ( 1.0 + 2.0 * (new_n - 2.0)/M_PI - new_n));
				break;

			case 4: /* u < (1-alpha) */
				*fu = A * B * ( u + (new_n - 1.0) * (new_n - 1.0) * B *
									cos( (u - (1.0 - alpha )) / (B * (new_n - 1.0)) ) +
							 (new_n - 1.0 + 2.0 * new_n * alpha * (1.0 + (new_n - 2.0) / M_PI - new_n)));
				break;

			default:
				*fu = A * B * (u - B * sin((u - 1.0) / B) + 2.0 * B * new_n * (new_n - 2.0) + (new_n - 1.0) * (1.0 - 2.0 * new_n * alpha));
				break;
		}
	}

	if( dfu )
	{
		switch(region)
		{
			case 1: /* u < alpha */
				*dfu = A * B *( 1.0 - cos(u / B));
				break;

			case 2: /* u < new_n*alpha */
				*dfu = A * B * ( 1.0 + (new_n - 1.0) * sin( (u - alpha) / (B * (new_n - 1.0))));
				break;

			case 3: /* u < (1-new_n*alpha) */
				*dfu = A * B * new_n;
				break;

			case 4: /* u < (1-alpha) */
				*dfu = A * B * ( 1.0 - (new_n - 1.0) * sin( (u - (1.0 - alpha)) / (B * (new_n - 1.0))));
				break;

			default:
				*dfu = A * B * ( 1 - cos((u - 1.0) / B ));
				break;
		}
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1: /* u < alpha */
				*d2fu = A * sin(u / B);
				break;

			case 2: /* u < new_n*alpha */
				*d2fu = A * cos((u - alpha) / (B * (new_n - 1.0)));
				break;

			case 3: /* u < (1-new_n*alpha) */
				*d2fu = 0;
				break;

			case 4: /* u < (1-alpha) */
				*d2fu = -A * cos((u - (1.0 - alpha)) / (B * (new_n - 1.0)));
				break;

			default:
				*d2fu = A * sin((u - 1.0) / B);
				break;
		}
	}

	return 1;
}


XXInteger MotionProfilePolynomial345(XXDouble u, XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXInteger region;
	XXDouble u2, u3, u4, u5;

	region = 0;
	if( u == 0.0 )
		region = 1;
	else
	{
		if( u < 1.0 )
			region = 2;
		else
		{
			region = 0;
		}
	}

	switch(region)
	{
		case 1: /* u == 0.0 */
			if( fu )
				*fu = 0.0;
			if( dfu )
				*dfu = 0.0;
			if( d2fu )
				*d2fu = 0.0;
			break;

		case 2: /* u < 1.0 */

			u2 = u * u;
			u3 = u2 * u;
			u4 = u3 * u;
			u5 = u4 * u;

			if( fu )
				*fu = 10.0 * u3 - 15.0 * u4 + 6.0 * u5;
			if( dfu )
				*dfu = 30.0 * u2 - 60.0 * u3 + 30.0 * u4;
			if( d2fu )
 				*d2fu = 60.0 * u - 180.0 * u2 + 120.0 * u3;
			break;

		default:
			if( fu )
				*fu = 1.0;
			if( dfu )
				*dfu = 0.0;
			if( d2fu )
				*d2fu = 0.0;
			break;
	}


	return 1;
}

XXInteger MotionProfilePolynomial13579(XXDouble u, XXDouble bb, XXDouble bm,
								  XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble a1, a3, a5, a7, a9;
	XXInteger region;
	XXDouble TT, TT2, TT3, TT4, TT5, TT6, TT7, TT8, TT9;

	a1 = (-bb - 8.0 * bm + 1260.0) / 768.0;
	a3 = bm / 6.0;
	a5 = (bb - 8.0 * bm - 252.0) / 8.0;
	a7 = (-2.0 * bb + 8.0 * bm + 360.0 ) /3.0;
	a9 = (3.0 * bb - 8.0 * bm - 420.0) / 3.0;

	region = 0;
	if( u <= 0.0 )
		region = 1;
	else
	{
		if( u < 1.0 )
			region = 2;
		else
		{
			region = 0;
		}
	}

	TT = u - 0.5;

	switch(region)
	{
		case 1: /* u <= 0.0 */
			if( fu )
				*fu = 0.0;
			if( dfu )
				*dfu = 0.0;
			if( d2fu )
				*d2fu = 0.0;
			break;

		case 2: /* u < 1.0 */
			TT2 = TT * TT;
			TT3 = TT2 * TT;
			TT4 = TT2 * TT2;
			TT5 = TT4 * TT;
			TT6 = TT3 * TT3;
			TT7 = TT4 * TT3;
			TT8 = TT4 * TT4;
			TT9 = TT4 * TT5;

			if( fu )
				*fu = 0.5 + a1 * TT + a3 * TT3 + a5 * TT5 + a7 * TT7 + a9 * TT9;
			if( dfu )
				*dfu = a1 + 3.0 * a3 * TT2 + 5.0 * a5 * TT4 + 7.0 * a7 * TT6 + 9.0 * a9 * TT8;
			if( d2fu )
	 			*d2fu = 6.0 * a3 * TT + 20.0 * a5 * TT3 + 42.0 * a7 * TT5 + 72.0 * a9 * TT7;
			break;

		default:
			if( fu )
				*fu = 1.0;
			if( dfu )
				*dfu = 0.0;
			if( d2fu )
				*d2fu = 0.0;
			break;
	}


	return 1;
}

/* the crankLength and the rodlength are non-normalized */
XXInteger MotionProfileCrankRod(XXDouble u, XXDouble crankLength, XXDouble rodLength,
						   XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	/*
	 * first declarations, because this same code may be used for
	 * ANSI C-Code
	 */
	XXDouble sinPiu, cosPiu, sqrtArg, sqrtCalc;
	XXDouble sc2, s2;

	sinPiu = sin(M_PI*u);
	cosPiu = cos(M_PI*u);

	sqrtArg = (rodLength * rodLength)/(crankLength * crankLength) - sinPiu * sinPiu;

	if( sqrtArg < 0.0 )
	{
		sqrtCalc = 0.0;
	}
	else
	{
		sqrtCalc = sqrt(sqrtArg);
	}

	if( fu )
	{
		if( sqrtArg < 0.0 )
		{
			*fu = 0.0;
		}
		else
		{
			*fu = 0.5 * (-cosPiu + sqrtCalc + 1.0 - rodLength / crankLength);
		}
	}

	if( dfu )
	{
		if( sqrtCalc == 0.0 )
		{
			*dfu = 0.0;
		}
		else
		{
			*dfu = M_HALFPI * ( sinPiu - ((sinPiu * cosPiu) / sqrtCalc) );
		}
	}

	if( d2fu )
	{
		sc2 = sinPiu * cosPiu;
		sc2 *= sc2;
		s2 = sinPiu * sinPiu;
		if( sqrtCalc == 0.0 )
		{
			*d2fu = 0.0;
		}
		else
		{
			*d2fu = M_PISQR * (
							cosPiu -
							sc2 / ((sqrtArg) * sqrtCalc) -
						(1.0 - 2.0 * s2) / sqrtCalc
						);
		}
	}

	return 1;
}

/*
 * no further arguments
 */
XXInteger MotionProfileGenevaMechanism(XXDouble u,
								  XXDouble *fu, XXDouble *dfu, XXDouble *d2fu)
{
	XXDouble sincosArg;
	XXInteger region;

	region = 0;

	if( u <= 0.0 )
	{
		region = 1;
	}
	else
	{
		if( u < 1.0 )
			region = 2;
	}

	sincosArg = u * M_HALFPI - M_QRTRPI;
	if( fu )
	{
		switch(region)
		{
			case 1: /* u <= 0.0 */
				*fu = 0.0;
				break;

			case 2: /* u < 1.0 */
				*fu = ( 2.0/ M_PI) * atan( sin(sincosArg) / ( M_SQRT2 - cos(sincosArg))) + 0.5;
				break;

			default:
				*fu = 1.0;
				break;
		}
	}

	if( dfu)
	{
		switch(region)
		{
			case 1: /* u <= 0.0 */
				*dfu = 0.0;
				break;

			case 2: /* u < 1.0 */
				*dfu = ( M_SQRT2*cos(sincosArg) -1.0 )/( 3.0 - 2.0*M_SQRT2*cos(sincosArg));
				break;

			default:
				*dfu = 0.0;
				break;
		}
	}

	if( d2fu )
	{
		switch(region)
		{
			case 1: /* u <= 0.0 */
				*d2fu = 0.0;
				break;

			case 2: /* u < 1.0 */
				*d2fu =  (-M_HALFPI * M_SQRT2 * sin(sincosArg) ) /
						( 9.0 - 12.0 * M_SQRT2 * cos(sincosArg) + 8.0 * (cos(sincosArg) * cos(sincosArg)) );
				break;

			default:
				*d2fu = 0.0;
				break;
		}
	}

	return 1;
}

%ENDIF%