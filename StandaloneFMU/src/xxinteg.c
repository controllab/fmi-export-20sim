/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* This file describes the integration methods
   that are supplied for computation.

   Currently the following methods are supported:
   * Euler
   * RungeKutta2
   * RungeKutta4
   but it is easy for the user to add their own
   integration methods with these two as an example.
*/

/* the system include files */
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* our own include files */
#include "xxinteg.h"
#include "xxmodel.h"

%IF%%NUMBER_STATES%
#define %VARPREFIX%STATE_SIZE %NUMBER_STATES%

%ENDIF%
%IF%%FMI1%
#define FMI_LOG_ERROR(model_instance, message)	if ( model_instance->fmiCallbackFunctions.logger != NULL)\
	{\
		model_instance->fmiCallbackFunctions.logger(NULL, "%SUBMODEL_NAME%", fmiError, "error",\
			message);\
	}

%ENDIF%
%IF%%FMI2%
#define FMI_LOG_ERROR(model_instance ,message)	if (model_instance->fmiCallbackFunctions != NULL && model_instance->fmiCallbackFunctions->logger != NULL)\
	{\
		model_instance->fmiCallbackFunctions->logger(NULL, "%SUBMODEL_NAME%", fmi2Error, "error",\
			message);\
	}


%ENDIF%
#ifdef Discrete_METHOD
/*********************************************************************
 * Discrete integration method
 *********************************************************************/

/* the initialization of the Discrete integration method */
XXBoolean %FUNCTIONPREFIX%DiscreteInitialize (%VARPREFIX%ModelInstance* model_instance)
{
	/* The internal time is set to the start time
	 * so set our discrete time to this value as well
	 */
	model_instance->m_discrete_time = model_instance->time;
	model_instance->major = XXTRUE;

	return XXTRUE;
}

/* the termination of the Discrete integration method */
XXBoolean %FUNCTIONPREFIX%DiscreteTerminate (%VARPREFIX%ModelInstance* model_instance)
{
	/* nothing to be done */
	return XXTRUE;
}

/* the Discrete integration method itself */
XXBoolean %FUNCTIONPREFIX%DiscreteStep (%VARPREFIX%ModelInstance* model_instance, XXDouble outputTime)
{
%IF%%NUMBER_STATES%
	XXInteger index;

	/* check if the next discrete time point is beyond the outputTime */
	if( model_instance->m_discrete_time + model_instance->step_size > outputTime )
	{
		/* no need to take a discrete step yet
		 * we just update the internal time, but leave the discrete time as is
		 */
		model_instance->time = outputTime;

		/* and just return */
		return XXTRUE;
	}

	/* for each of the supplied states */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* just a move of the new state */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->%XX_RATE_ARRAY_NAME% [index];
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation discrete time */
	model_instance->m_discrete_time += model_instance->step_size;

	/* and set the continious time to the discrete time */
	model_instance->time = model_instance->m_discrete_time;

	model_instance->major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);

	return XXTRUE;
}
#endif /* Discrete_METHOD */


#ifdef Euler_METHOD
/*********************************************************************
 * Euler integration method
 *********************************************************************/

/* the initialization of the Euler integration method */
XXBoolean %FUNCTIONPREFIX%EulerInitialize (%VARPREFIX%ModelInstance* model_instance)
{
	/* nothing to be done */
	model_instance->major = XXTRUE;
	return XXTRUE;
}

/* the termination of the Euler integration method */
XXBoolean %FUNCTIONPREFIX%EulerTerminate (%VARPREFIX%ModelInstance* model_instance)
{
	/* nothing to be done */
	return XXTRUE;
}

/* the Euler integration method itself */
XXBoolean %FUNCTIONPREFIX%EulerStep (%VARPREFIX%ModelInstance* model_instance, XXDouble outputTime)
{
	XXDouble stepSize = model_instance->step_size;
	%VARPREFIX%ModelInstance *mi = model_instance;
%IF%%NUMBER_STATES%
	XXInteger index;
%ENDIF%
	XXDouble output_time = (model_instance->m_use_finish_time ?
	  (model_instance->finish_time > outputTime ? outputTime : model_instance->finish_time)
	:
	  outputTime);

	if( output_time - model_instance->time < stepSize )
	{
		/* limit the step size */
		stepSize = output_time - model_instance->time;
	}

%IF%%NUMBER_STATES%
	/* for each of the supplied states */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* calculate the new state */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->%XX_STATE_ARRAY_NAME% [index] + model_instance->%XX_RATE_ARRAY_NAME% [index] * stepSize;
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation time */
	model_instance->time += stepSize;

	model_instance->major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);

	return XXTRUE;
}
#endif /* Euler_METHOD */


#ifdef RungeKutta2_METHOD
/*********************************************************************
 * RungeKutta2 integration method
 *********************************************************************/
/* the initialization of the RungeKutta2 integration method */
XXBoolean %FUNCTIONPREFIX%RungeKutta2Initialize (%VARPREFIX%ModelInstance* model_instance)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (model_instance->q0, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
%ENDIF%
	return XXTRUE;
}

/* the termination of the RungeKutta2 integration method */
XXBoolean %FUNCTIONPREFIX%RungeKutta2Terminate (%VARPREFIX%ModelInstance* model_instance)
{
	/* nothing yet (our arrays are static) */
	return XXTRUE;
}

/* the Runge-Kutta-2 integration method itself */
XXBoolean %FUNCTIONPREFIX%RungeKutta2Step (%VARPREFIX%ModelInstance* model_instance, XXDouble outputTime)
{
	XXDouble stepSize = model_instance->step_size;
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;
%ENDIF%

	XXDouble output_time = (model_instance->m_use_finish_time ?
	  (model_instance->finish_time > outputTime ? outputTime : model_instance->finish_time)
	: outputTime);

	/* check if we have to limit our stepsize to get exactly at the outpuTime */
	if( output_time - model_instance->time < stepSize )
	{
		/* limit the step size */
		stepSize = output_time - model_instance->time;
	}

%IF%%NUMBER_STATES%
	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate result                                        */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = model_instance->time;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (model_instance->q0, model_instance->%XX_STATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* calculate f (states, t) * 1/2 * dt  =  rates * 1/2 * dt  */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the new states to use */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->q0 [index] + model_instance->%XX_RATE_ARRAY_NAME% [index] * 0.5 * stepSize;
	}

	model_instance->time = rktime + 0.5 * stepSize;
	model_instance->major = XXFALSE;
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->q0 [index] + model_instance->%XX_RATE_ARRAY_NAME% [index] * stepSize;
	}
	model_instance->time = rktime + stepSize;

%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	model_instance->time += stepSize;

%ENDIF%
	model_instance->major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);
	return XXTRUE;
}
#endif /* RungeKutta2_METHOD */


#ifdef RungeKutta4_METHOD
/*********************************************************************
 * RungeKutta4 integration method
 *********************************************************************/

/*********************************************************************
 * the initialization of the RungeKutta4 integration method
 */
static const XXDouble OneOverSix = 1.0 / 6.0;

XXBoolean %FUNCTIONPREFIX%RungeKutta4Initialize (%VARPREFIX%ModelInstance* model_instance)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (model_instance->q0, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q1, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q2, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q3, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q4, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
%ENDIF%
	return XXTRUE;
}

/* the termination of the RungeKutta4 integration method */
XXBoolean %FUNCTIONPREFIX%RungeKutta4Terminate (%VARPREFIX%ModelInstance* model_instance)
{
	/* nothing yet (our arrays are static) */
	return XXTRUE;
}

/* the Runge-Kutta-4 integration method itself */
XXBoolean %FUNCTIONPREFIX%RungeKutta4Step (%VARPREFIX%ModelInstance* model_instance, XXDouble outputTime)
{
	XXDouble stepSize = model_instance->step_size;
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;
%ENDIF%

	XXDouble output_time = (model_instance->m_use_finish_time ?
	  (model_instance->finish_time > outputTime ? outputTime : model_instance->finish_time)
	: outputTime);

	/* check if we have to limit our stepsize to get exactly at the outpuTime */
	if( output_time - model_instance->time < stepSize )
	{
		/* limit the step size */
		stepSize = output_time - model_instance->time;
	}

%IF%%NUMBER_STATES%
	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate state results q1, q2, q3 and q4               */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = model_instance->time;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (model_instance->q0, model_instance->%XX_STATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* calculate q1 = f (states, t) * dt  =  rates * dt  */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the intermediate q1 */
		model_instance->q1 [index] = model_instance->%XX_RATE_ARRAY_NAME% [index] * stepSize;

		/* set the new states to use  for q2 */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->q0 [index] + model_instance->q1 [index] / 2;
	}

	/* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
	model_instance->time = rktime + 0.5 * stepSize;

	model_instance->major = XXFALSE;

	%FUNCTIONPREFIX%CalculateDynamic (model_instance);
	memcpy (model_instance->q2, model_instance->%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q2 */
		model_instance->q2 [index] = model_instance->q2 [index] * stepSize;

		/* set the new states to use */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->q0 [index] + model_instance->q2 [index] / 2;
	}

	/* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);
	memcpy (model_instance->q3, model_instance->%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q3 */
		model_instance->q3 [index] = model_instance->q3 [index] * stepSize;

		/* set the new states */
		model_instance->%XX_STATE_ARRAY_NAME% [index] = model_instance->q0 [index] + model_instance->q3 [index];
	}

	/* calculate q4 = f (states + q3, t + dt) * dt */
	model_instance->time = rktime + stepSize;
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);
	memcpy (model_instance->q4, model_instance->%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q4 */
		model_instance->q4 [index] = model_instance->q4 [index] * stepSize;

		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		model_instance->%XX_STATE_ARRAY_NAME%[index] = model_instance->q0[index] + (model_instance->q1[index] + model_instance->q2[index] + model_instance->q2[index] + model_instance->q3[index] + model_instance->q3[index] + model_instance->q4[index]) * OneOverSix;
	}
%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	model_instance->time += stepSize;
%ENDIF%

	model_instance->major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic (model_instance);
	return XXTRUE;
}
#endif /* RungeKutta4_METHOD */
